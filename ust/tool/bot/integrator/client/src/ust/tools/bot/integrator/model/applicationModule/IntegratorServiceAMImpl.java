package ust.tools.bot.integrator.model.applicationModule;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;

import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

import oracle.jbo.client.Configuration;
import oracle.jbo.server.ApplicationModuleImpl;

import ust.tools.bot.integrator.model.util.Cache;
import ust.tools.bot.integrator.model.util.Constants;
import ust.tools.bot.integrator.model.util.DeploymentRequest;
import ust.tools.bot.integrator.model.util.Environment;
import ust.tools.bot.integrator.model.util.Util;


// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Tue May 16 14:20:10 IST 2017
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class IntegratorServiceAMImpl extends ApplicationModuleImpl {


    private static final Map<String, Boolean> VIEW_STATE = new HashMap<String, Boolean>();





    public static void main(String[] args) {
        System.out.println("Start");
        try {
            IntegratorServiceAMImpl intgAM =
                (IntegratorServiceAMImpl) Configuration.createRootApplicationModule("ust.tools.bot.integrator.service.applicationmodule.IntegratorServiceAM",
                                                                                    "IntegratorServiceAMLocal");
            //String output = intgAM.process("ade lsviews && ade pwv");
            String output = intgAM.process("300100090358733");
            System.out.println(output);
            System.out.println("End");
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public String process(String message) {
        IntegratorClientAMImpl modelAM = (IntegratorClientAMImpl) this.getIntegratorClientAM();
        Long requestId = Long.valueOf(message.trim());
        DeploymentRequest request = modelAM.getDeploymentRequest(requestId);
        StringBuffer output = new StringBuffer();
        Long envId = request.getEnvironment().getEnvironmentId();
        
        String targetWindow = Util.getTargetWindow(request.getEnvironment(), request.getProductCode());
        request.setTargetWindow(targetWindow);

        try {
            String vn = request.getTargetWindow();
            if (VIEW_STATE.get(vn) == null) {
                List<String> pvCmds = Cache.INT_COMMANDS.get(Constants.PREPARE_VIEW);
                executeCommands(request, null, pvCmds, output);
                VIEW_STATE.put(vn, true);
                //scheduleCron4PostFetchScript(request, request.getEnvironment(), output);
                //scheduleTimer4PostFetchScript(request, request.getEnvironment(), output);
                Map<String, DeploymentRequest> requests =
                    modelAM.getDeploymentRequests4NextCycle(envId, "FETCHED", request.getTargetWindow(), request.getProductCode());
                fetchTransactions(requests, request.getTargetWindow());
            }
            List<String> fcCmds = Cache.INT_COMMANDS.get(Constants.FETCH_TRANS);
            executeCommands(request, null, fcCmds, output);

            String status = "FETCHED";
            if (output != null) {
                if (output.indexOf("conflicts are outstanding )") > -1) {
                    status = "CONFLICTS_FOUND";
                } else if (output.indexOf(request.getTxnName() + " does not exist in backend") > -1) {
                    status = "DOES_NOT_EXIST";
                }
            }
            if ("CONFLICTS_FOUND".equalsIgnoreCase(status)) {
                sendEmailForConflicts(request, output);
            } else if ("FETCHED".equalsIgnoreCase(status)) {
                sendEmailForFetched(request, output);
            }else {
                sendEmailForOtherStatus(request, output);
            }
            modelAM.updateTxnFetchStatus(request.getRequestId(), request.getTargetWindow(), request.getTxnName(),
                                         status);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return output.toString();
    }


    private void executeCommands(DeploymentRequest request, Map<String, String> tokens, List<String> commands,
                                 StringBuffer log) {
        try {

            String envName = request.getEnvironment().getEnvironmentName();
            String reqTxn = request.getTxnName();
            String userEmail = request.getRequestorEmail();

            ProcessBuilder builder = new ProcessBuilder("/bin/bash");
            Process process = builder.start();

            BufferedWriter pi = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
            Scanner s = new Scanner(process.getInputStream());
            String viewName = request.getTargetWindow();
            String series = request.getEnvironment().getAdeBranch();

            if (tokens != null) {
                Set<String> tNames = tokens.keySet();
              //  System.out.println("-------- Tokens --------");
                for (String tName : tNames) {
                    String tValue = tokens.get(tName);
                  //  System.out.println(tName + " : " + tValue);
                }
            }
            if (commands != null) {
                for (String command : commands) {
                    command = command.replaceAll("viewname", viewName);
                    command = command.replaceAll("transname", reqTxn);
                    command = command.replaceAll("seriesname", series);
                    command = command.replaceAll("environment", envName);
                    command = command.replaceAll("log.log", reqTxn + ".log");
                    command = command.replaceAll("useremail", userEmail);
                    command = command.replaceAll("mitradir", Constants.MITRA_DIR);
                    command = command.replaceAll("pcode", request.getProductCode());
                    command = command.replaceAll("intgemails", Cache.getIntgEmailsString());

                    if (tokens != null) {
                        Set<String> tNames = tokens.keySet();
                        for (String tName : tNames) {
                            String tValue = tokens.get(tName);
                            command = command.replaceAll(tName, tValue);
                        }
                    }

                    System.out.println(command);
                    pi.write("echo '" + command + "'");
                    pi.newLine();
                    pi.flush();

                    pi.write(command);
                    pi.newLine();
                    pi.flush();

                }
                while (s.hasNextLine()) {
                    log.append(s.nextLine());
                    log.append("\n");
                }
                s.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void fetchTransactions(Map<String, DeploymentRequest> requests, String targetWindow) {
        if (requests != null) {
            Set<String> txnNames = requests.keySet();
            for (String txnName : txnNames) {
                System.out.println("Trans Name:" + txnName);
                DeploymentRequest request = requests.get(txnName);
                if (targetWindow == null) {
                    targetWindow = Util.getTargetWindow(request.getEnvironment(), request.getProductCode());
                }
                System.out.println("Fetching Transaction:" + txnName + " into TargetWindow : " + targetWindow);
                DeploymentRequest newOneTimeRequest = createNewOneTimeDeploymentRequest(request, targetWindow);
                boolean logged =
                    ((IntegratorClientAMImpl) getIntegratorClientAM())
                    .logDeploymentRequestIfDoesNotExists(newOneTimeRequest);
                if (!logged) {
                    System.out.println(txnName + " was already fetched, ignoring it now");
                    continue;
                }
                List<String> fcCmds = Cache.INT_COMMANDS.get(Constants.FETCH_TRANS);
                StringBuffer output = new StringBuffer();
                executeCommands(newOneTimeRequest, null, fcCmds, output);
                IntegratorClientAMImpl modelAM = (IntegratorClientAMImpl) this.getIntegratorClientAM();

                String status = "FETCHED";
                if (output != null) {
                    if (output.indexOf("conflicts are outstanding )") > -1) {
                        status = "CONFLICTS_FOUND";
                    } else if (output.indexOf(request.getTxnName() + " does not exist in backend") > -1) {
                        status = "DOES_NOT_EXIST";
                    }
                }
                if ("CONFLICTS_FOUND".equalsIgnoreCase(status)) {
                    sendEmailForConflicts(newOneTimeRequest, output);
                } else if ("FETCHED".equalsIgnoreCase(status)) {
                    sendEmailForFetched(newOneTimeRequest, output);
                }else {
                    sendEmailForOtherStatus(newOneTimeRequest, output);
                }

                modelAM.updateTxnFetchStatus(newOneTimeRequest.getRequestId(), targetWindow, request.getTxnName(),
                                             status);
            }
        }
    }

    private void sendEmailForConflicts(DeploymentRequest request, StringBuffer output) {
        List<String> ecCmds = Cache.INT_COMMANDS.get(Constants.EMAIL_CONFLICTS);
        String intgEmails =
            ((IntegratorClientAMImpl) getIntegratorClientAM()).getIntegratorsStringForProduct(request.getProductCode());
        Map<String, String> tokens = new HashMap<String, String>();
        if (intgEmails != null && !intgEmails.isEmpty()) {
            tokens.put("intgemails", intgEmails);
        }

        executeCommands(request, tokens, ecCmds, output);
    }
    
    private void sendEmailForFetched(DeploymentRequest request, StringBuffer output) {
        List<String> encCmds = Cache.INT_COMMANDS.get(Constants.EMAIL_FETCHED );
        executeCommands(request, null, encCmds, output);
    }

    private void sendEmailForOtherStatus(DeploymentRequest request, StringBuffer output) {
        List<String> encCmds = Cache.INT_COMMANDS.get(Constants.EMAIL_NOT_EXISTS);
        executeCommands(request, null, encCmds, output);
    }

    private DeploymentRequest createNewOneTimeDeploymentRequest(DeploymentRequest parentRequest, String targetWindow) {
        DeploymentRequest newOneTimeRequest = new DeploymentRequest();
        newOneTimeRequest.setDeploymentStatus("REQUESTED");
        newOneTimeRequest.setEnvironment(parentRequest.getEnvironment());
        newOneTimeRequest.setProductCode(parentRequest.getProductCode());
        newOneTimeRequest.setRequestorEmail(parentRequest.getRequestorEmail());
        newOneTimeRequest.getDeployTypes().addAll(parentRequest.getDeployTypes());
        newOneTimeRequest.getSoaComposites().addAll(parentRequest.getSoaComposites());
        newOneTimeRequest.setTargetWindow(targetWindow);
        newOneTimeRequest.setTxnName(parentRequest.getTxnName());
        newOneTimeRequest.setParentRequestId(parentRequest.getRequestId());
        return newOneTimeRequest;
    }


    private void scheduleCron4PostFetchScript(DeploymentRequest request, Environment env, StringBuffer log) {
        System.out.println("Scheduling Cron");

        List<String> cronCmds = Cache.INT_COMMANDS.get(Constants.SCHEDULE_CRON_POST_FETCH);
        Map<String, String> tokens = new HashMap<String, String>();
        String startTime = Util.getNextWindowStartTimeServer(env);
        System.out.println("Next window start time:" + startTime + " for targetwindow:" + request.getTargetWindow());

        Calendar calender = Calendar.getInstance();
        calender.set(Calendar.YEAR, Integer.valueOf(startTime.substring(0, 4)));
        calender.set(Calendar.MONTH, Integer.valueOf(startTime.substring(4, 6)));
        calender.set(Calendar.DAY_OF_MONTH, Integer.valueOf(startTime.substring(6, 8)));
        calender.set(Calendar.HOUR_OF_DAY, Integer.valueOf(startTime.substring(8, 10)));
        if (startTime.length() == 10) {
            calender.set(Calendar.MINUTE, 0);
        } else {
            calender.set(Calendar.MINUTE, Integer.valueOf(startTime.substring(10, startTime.length())));
        }

        Long utcTimeInMillis = Util.toUTC(calender.getTimeInMillis(), calender.getTimeZone());
        Calendar utcCal = Calendar.getInstance();
        utcCal.setTimeInMillis(utcTimeInMillis);


        String monthOfYear = String.valueOf(utcCal.get(Calendar.MONTH));
        String dayOfMonth = String.valueOf(utcCal.get(Calendar.DAY_OF_MONTH));
        String hourOfDay = String.valueOf(utcCal.get(Calendar.HOUR_OF_DAY));
        String minuteOfHour = String.valueOf(utcCal.get(Calendar.MINUTE));


        if (minuteOfHour.trim().length() == 0) {
            minuteOfHour = "00";
        }


        String pTargetWindow = Util.getPreviousTargetWindow(request.getEnvironment(), request.getProductCode());
        if ("SMC".equalsIgnoreCase(env.getEnvironmentType())) {
            tokens.put("template", "SMC");
        } else {
            tokens.put("template", "CLASSIC");
        }
        tokens.put("previousname", pTargetWindow);
        tokens.put("monthofyear", monthOfYear);
        tokens.put("dayofmonth", dayOfMonth);
        tokens.put("hourofday", hourOfDay);
        tokens.put("minuteofhour", minuteOfHour);
        tokens.put("mitradir", Constants.MITRA_DIR);
        String intgEmails =
            ((IntegratorClientAMImpl) getIntegratorClientAM()).getIntegratorsStringForProduct(request.getProductCode());
        if (intgEmails != null && !intgEmails.isEmpty()) {
            tokens.put("intgemails", intgEmails);
        }
        this.executeCommands(request, tokens, cronCmds, log);
        //Util.executeTimedTask(cronCmds, tokens, log, calender.getTime());
    }
    

    /**
     * Container's getter for IntegratorClientAM1.
     * @return IntegratorClientAM1
     */
    public ApplicationModuleImpl getIntegratorClientAM() {
        return (ApplicationModuleImpl) findApplicationModule("IntegratorClientAM");
    }
}
